\documentclass{article}

%%% Defines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{shapes.misc}
\usepackage[european,straightvoltages]{circuitikz}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel} 
\usepackage[colorlinks]{hyperref}
\usepackage{caption, float, subcaption}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{mathtools, amssymb, ntheorem, amsmath, siunitx}
\sisetup{per-mode=fraction, separate-uncertainty=true,exponent-base=10,output-decimal-marker={,}}
\DeclareSIUnit\liter{l}
\usepackage{enumitem}
\usepackage{minted}
\usepackage{placeins}

\usepackage{tikz-uml}

% manuelle hyponation
\hyphenation{Än-de-run-gen}


% maths
\newcommand{\abs}[1]{\left| #1 \right|}
\newcommand{\br}[1]{\left( #1 \right)}
\newcommand{\ubar}[1]{\mkern 1.5mu\underline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}

% image
\newcommand{\img}[5]{
    \begin{figure} [#5]
    \centering
    \includegraphics[width=#2\linewidth]{#1}
    \caption{#3}
    \label{pic:#4}
    \end{figure}
}

% tikz
\newenvironment{gfx}[3]
{
    \newcommand{\gfxname}{#2}
    \newcommand{\gfxcaption}{#1}
    \begin{figure} [#3]
    \centering
    \begin{tikzpicture}
}
{
    \end{tikzpicture}
    \caption{\gfxcaption}
    \label{gfx:\gfxname}
    \end{figure}
}

\newcommand{\opt}{\ensuremath{\parallel}}

% cicuitikz
\newenvironment{ckt}[3]
{
    \newcommand{\cktname}{#2}
    \newcommand{\cktcaption}{#1}
    \begin{figure} [#3]
    \centering
    \begin{circuitikz}
	\draw
}
{
	;
    \end{circuitikz}
    \caption{\cktcaption}
    \label{ckt:\cktname}
    \end{figure}
}

% Code
\newfloat{Code}{htbp}{loc}
\floatname{Code}{Quelltext}
\definecolor{LightGray}{gray}{0.9}
\newenvironment{code}[4]
{%
  \VerbatimEnvironment
  \begin{Code} [#4]
  \caption{#2}%
  \label{cod:#3}%
  \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,bgcolor=LightGray,fontsize=\footnotesize,style=emacs]{#1}%
}
{%
  \end{minted}%
  \vspace{-20pt}%
  \end{Code}%
}
\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\makeatother
\newcommand{\listofcode}{
  \doublespacing
  \listof{Code}{Quelltextverzeichnis}
}

%%% Head %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Title}
\author{Benjamin Brohs, Kevin Hecke, Justin Meng}
\date{Date}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

\begin{document}

%%% Title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
  \centering
	\begin{tabular}{lcr}
		\includegraphics[width=0.35\textwidth]{fachbereich.png} & \hspace{0.195\textwidth} & \includegraphics[width=0.35\textwidth]{Q04_HTW_Berlin_Logo_quer_pos_FARBIG_RGB.jpg}\\
	\end{tabular}	
	\\[3cm]
	\Large
	Belegarbeit\\
	\vspace{2cm}
	\textbf{Minecraft-One-Week-Challenge Reloaded}\\
	\vspace{2cm}
	\begin{tabular}{ll} 
		Im Studiengang: & Computer Engineering \\		
	\end{tabular}	
	\\[3cm]
	\normalsize
	\begin{tabular}{ll}
	      \textbf{Erstellt von:} & Benjamin Brohs, Kevin Hecke, Justin Meng \\
        \textbf{Modul:} & Softwaretechnik \\
        \textbf{Semester:} & Sommersemester 2025 \\
	\textbf{Dozent:} & Thomas Baar
	\end{tabular}	
\end{titlepage}

\tableofcontents

\newpage

%%% Inhalt %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Meilenstein 1} \label{sec:ms1}

Meilenstein 1 befasst sich mit der Beschreibung der Software, wie sie ohne die Änderung aufgebaut ist. Sowohl textuell, als auch per Modell.

\subsection{Informelle Beschreibung} \label{subsec:inf}

Die ausgewählte Software ist ein Projekt eines YouTubers, in einer Woche einen Klon des bekannten Spiels \href{https://www.minecraft.net}{Minecraft} zu programmieren. Bei dem Spiel Minecraft handelt es sich um ein sogenanntes Open-World Survival Game. Das bedeutet, der Spieler findet sich in einer algorithmisch generierten Welt wieder, die frei von dem Spieler erkundet werden kann. In dieser Welt hat der Spieler die Aufgabe gegen KI-gesteuerte Monster zu überleben. Zudem ist Minecraft für den stilisierten Grafikstil bekannt, der durch die Verwendung von quadratischen Blöcken und pixeligen Texturen geprägt ist.

Eben diese Eigenschaften wurden aufgegriffen und in einer einfachen C++ Umgebung mithilfe von OpenGL nachgeahmt. Der Spieler wird auch hier in eine generierte offene Welt gesetzt und kann sich darin frei bewegen und erkunden. Dem Spieler ist es dabei möglich, in alle Richtungen zu laufen, über Hindernisse zu springen, zu sprinten und zu schleichen. Die Welt in der sich der Spieler bewegt, generiert auch einige Gewässer verschiedener Grö\ss{}en, in dieser Instanz des Spiels ist es dem Spieler aber nicht möglich darin zu schwimmen. Nun kann der Spieler diese Welt auch nach belieben verändern. Weniger komplex als im Basis Spiel, kann der Spieler ohne Bedingungen jeden Block aufnehmen und woanders wieder platzieren. Es wurden zusätzliche Funktionen implementiert, z.B. den Mauszeiger zu eizufangen und freizugeben, da das Projekt keine Benutzeroberfläche implementiert.

Die Spielwelt selber wird mithilfe von Rauschfunktionen generiert, spezieller einer Art Value-Noise. Damit soll die Generierung des Geländes natürlicher wirken. Zudem gibt es verschiedene Biome in der Welt, die ebenso zufällig verstreut sind und verschiedene Strukturen von Vegetation und unterschiedliche Arten von Blöcken generieren. So gibt es zum Beispiel Wüsten, in denen Kakteen wachsen oder Wälder, in denen Bäume stehen.

In dieser Kopie des Spiels sind einige Haupt-Eigenschaften noch nicht umgesetzt. Es gibt keine weiteren Spiel-gesteuerten Entitäten in dem Klon, wie die Monster und Tiere die es im Basis Spiel gibt. Auch hat der Spieler nicht die Möglichkeit Schaden zu nehmen, zu schwimmen, in sein Inventar zu schauen oder verschiedene Materialien und Werkzeuge herzustellen. Das Projekt verfolgt nicht das Ziel, ein vollständiges Spiel zu sein, sondern entstand im Rahmen einer technischen Herausforderung. Es dient in erster Linie als Grundlage für Lernzwecke, zur Analyse grundlegender Spielmechaniken sowie als Ausgangspunkt für mögliche Erweiterungen durch Dritte. Das Original Open-Source-Projekt ist zu finden unter \url{https://github.com/Hopson97/MineCraft-One-Week-Challenge}.

Im Laufe des Projekts wurden einige der Standard-Funktionen dazu programmiert. Die Bewegung des Spielers wurde erweitert um die Fähigkeit in Wasser zu schwimmen, und beim Schleichen nicht von Kanten zu fallen. Ebenso können verschiedene Blöcke nach konfiguration rutschiger sein als andere und man kann auch von den Blöcken elastisch wieder nach oben geworfen werden. UM sich in dem Spiel zurechfinden zu können wurden einige Grundelemente der Nutzeroberfläche hinzugefügt, darunter ein Fadenkreuz zum anvisieren der Blöcke, ein Inventarleiste, die die getragenen Items anzeigt und ein Debug-Menü, in dem wichtige Daten dargestellt werden. Ebenso wurde die Generierung der Welt etwas angepasst, jetzt sollen Bäume und andere Strukturen nicht nur in ihrem Chunk generieren, damit sie anders als vorher, an den Chunkgrenzen nicht anbgeschnitten werden.

\newpage
\subsection{Use-Case-Modell} \label{subsec:usecase}

Folgender Abschnitt thematisiert das Use-Case Modell der Software. Es handelt sich hier um ein Spiel, das alleine gespielt wird, somit gibt es hier auch nur einen Akteur. Abbildung \ref{gfx:usecase} zeigt die UseCases, die in der Software implementiert sind. Diese sind in den folgenden Abschnitten näher beschrieben.

\begin{gfx}{Use-Case Diagramm}{usecase}{ht}
  % Systemgrenze
  \begin{umlsystem}[x=4, y=0]{Minecraft-Klon}
    \umlusecase[x=0, y=0]{Bewegen}
    \umlusecase[x=0, y=-1.5]{Springen}
    \umlusecase[x=0, y=-3]{Flugmodus umschalten}
    \umlusecase[x=0, y=-4.5]{Maussteuerung deaktivieren}
    \umlusecase[x=0, y=-6]{Block abbauen}
    \umlusecase[x=0, y=-7.5]{Block platzieren}
  \end{umlsystem}

  % Akteur
  \umlactor[x=-2, y=-4.5]{Spieler}

  % Assoziationen
  \umlassoc{Spieler}{usecase-1}
  \umlassoc{Spieler}{usecase-2}
  \umlassoc{Spieler}{usecase-3}
  \umlassoc{Spieler}{usecase-4}
  \umlassoc{Spieler}{usecase-5}
  \umlassoc{Spieler}{usecase-6}
\end{gfx}

Für die UseCases sollen einige Rahmenbedingungen definiert werden. Abbildung~\ref{gfx:state} zeigt, in welchen Bewegungszuständen sich die Spielfigur befinden kann. Zusätzlich soll definiert werden, welche physikalischen Bedingungen auf die Spielfigur wirken und welche Bedienelemente des Spiels keine UseCases bekommen (umformulieren)

\begin{gfx}{Bewegungszustände}{state}{ht}
  
  \umlstateinitial[x=-2.9,y=4,name=init]
  \umlstatefinal[x=6.1,y=4,name=final]

  \begin{umlstate}[x=0,y=0,name=spiel]{Spiel}

    \umlstateinitial[x=-3,y=0,name=subinit]
    \umlbasicstate[x=0,y=0,name=laufen]{Laufen}
    \umlbasicstate[x=6,y=0,name=fallen]{Fallen}
    \umlbasicstate[x=0,y=-6,name=schwimmen]{Schwimmen}
    \umlbasicstate[x=6,y=-6,name=fliegen]{Fliegen}

    \umltrans[anchor2=193]{subinit}{laufen}

    \umltrans[anchor1=215,anchor2=55]{fallen}{schwimmen}
    \coordinate (P) at (1.65,-3.5);
    \node[rotate=45] (N) at (P) {berührtWasser};

    \umltrans[anchor1=35,anchor2=235]{schwimmen}{fallen}
    \coordinate (P) at (4.45,-1.9);
    \node[rotate=45] (N) at (P) {verlässtWasser};

    \umltrans[]{fliegen}{laufen}
    \coordinate (P) at (2.1,-1.45);
    \node[rotate=-45] (N) at (P) {berührtBoden};

    \umltrans[]{laufen}{schwimmen}
    \coordinate (P) at (-.2,-3);
    \node[rotate=90] (N) at (P) {berührtWasser};

    \umltrans[]{fallen}{fliegen}
    \umltrans[]{fliegen}{fallen}
    \coordinate (P) at (5.8,-3);
    \node[rotate=90] (N) at (P) {flugUmschalten};

    \umltrans[arg=berührtWasser,pos=0.5,rotate=45]{fliegen}{schwimmen}
    \umltrans[anchor1=10,anchor2=170,arg={überKanteFallen, springen},pos=0.5,rotate=45]{laufen}{fallen}
    \umltrans[anchor1=190,anchor2=350,arg=berührtBoden,pos=0.5,rotate=45]{fallen}{laufen}

  \end{umlstate}

  \umltrans[anchor2=136]{init}{spiel}
  \umltrans[anchor1=46]{spiel}{final}

\end{gfx}

\FloatBarrier



\newpage

\subsubsection*{Rahmenbedingungen des Spiels}

\begin{itemize}
  \item \textbf{Bewegungszustände:} Die Spielfigur befindet sich das komplette Spiel über in mindestens einem dieser Spielzustände. Eingaben auf der Tastatur können basierend auf diesen zuständen unterschiedliche Aktionen hervorrufen.
  \item \textbf{Maussteuerung:} Solange die Maussteuerung nicht durch einen der später definierten Use-Cases ausgeschaltet wurde wird sie als immer aktiv angenommen. Selbst wenn nicht aktiv die Richtung geändert wird, zählt die Aktive Blickrichtung als gewählte Eingabe. Aus diesem Grund erhält diese keinen eigenen Use-Case und wird in anderen als Vorraussetzung genommen.
  \item \textbf{Horizontale Bewegung:} Die Bewegung der Spielfigur findet mit 20Hz statt, in festen Ticks, zwischen den Positionen wird interpoliert. Die Horizontale Bewegung erfolgt nach rekursiver Formel. Grob unterteilt sich die Beweung in einen Teil Momentum, also die vorherige Geschwindigkeit multipliziert mit mehreren Parametern zur Dämpfing dieser, und einen zweiten Teil der Beschleunigung. Momentum und Beschleunigung werden zur Geschwindigkeit addiert. Die Parameter hängen von dem Zustand der Spielfigur ab:
  \begin{itemize}
    \item \textbf{Laufen:} Ein Parameter der sowohl in Momentum also auch Beschleunigung Einfluss hat, ist die Haftreibung des Untergrunds. Zusätzlich gelten weiter spezifische Parameter, die extra zur präzisen Laufbewegung beitragen.
    \item \textbf{Fallen:} Hier spielt keine Haftreibung mehr eine Rolle, und die Bewegung wird annähernd wie beim laufen aber mit deutlich niedrigerer Reibung berechnet.
    \item \textbf{Fliegen:} Hier wird die gleiche horizontale Bewegung wie beim Laufen benutzt, aber verdoppelt, um sich schneller bewegen zu können.
    \item \textbf{Schwimmen:} Diese Bewegung ist mehr vereinfacht und hat deutlisch stärkere Reibung um dem Wasser ein anstrengendes Vorankommen zu simulieren
  \end{itemize}
  \item \textbf{Vertikale Bewegung:} Ebenso wid die vertikale Bewegung in Ticks berechnet. Sie ist jedoch nicht so kompliziert. Es wirkt hier eine konstante Beschleunigung nach unten um Schwerkraft zu simulieren. Diese wird der vorherigen Geschwindigkeit abgezogen und anschließlich mit einer Luftreibung multipliziert. Auch hier gibt es Unterschiede in den einzelnen Zuständen:
  \begin{itemize}
    \item \textbf{Laufen:} Wie beschrieben gild eine Schwerkraft, die der Kollision des Blockes undter den Füßen entgegenwirkt. bei einem Sprung wird statt Gravitation eine positive Anfangsgeschwindigkeit gesetzt.
    \item \textbf{Fallen:} Beim Fallen wirkt auch wie beschrieben die Schwerkraft. Der Zustand Fallen kann aber auch nach einem Spruing nach oben fliegen und durch die Gravitation abbremsen
    \item \textbf{Fliegen:} Hier gilt keine Schwerkraft und bewegung wird alleine durch die Eingaben bestimmt. Es werde hier ähnliche Formeln herangezogen, wie in der horizontalen Bewegung
    \item \textbf{Schwimmen:} Deser Zustand ist eine Kombination, wie beim Fliegen, kann man sich auf und ab bewegen, jedoch gilt eine Schwerkraft, die einen nach unten zieht, wenn auch nicht so stark
  \end{itemize}
\end{itemize}

\textit{Hinweis:} Diese Mechaniken gelten systemweit und werden innerhalb der Use Cases nicht vollständig modelliert, sondern vorausgesetzt. Ihre konkrete Auswirkung auf das Spielerlebnis ergibt sich aus dem Zusammenspiel dieser physikalischen Regeln mit den Eingaben des Spielers.

\newpage

\subsubsection*{UC01 – Bewegen}

\textbf{Name:} Bewegen \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Horizontale Fortbewegung der Spielfigur in der Spielwelt entsprechend der Eingaben \\
\textbf{Vorbedingungen:} Spiel läuft, Spielfigur ist aktiv, Spielfigur schaut in eine ausgewählte Blickrichtung \\
\textbf{Nachbedingungen:} Position der Spielfigur wurde angepasst \\
\textbf{Beschreibung:} Der Spieler bewegt die Spielfigur durch Eingabe von Bewegungstasten. Die Bewegungsrichtung wird durch die aktuelle Blickrichtung bestimmt. Der Use-Case bleibt aktiv, solange Eingaben erfolgen. Sprinten, Schleichen können die Fortbewegung beeinflussen.

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spiel validiert, dass Spieler im Zustand Laufen ist
  \item[2.] Spieler drückt Bewegungstasten (W/A/S/D)
  \item[2\opt a.] Spieler drückt zusätzlich Sprinttaste (Strg):
  \item[2\opt a.1.] Spiel erhöht horizontale Geschwindigkeit der Spielfigur
  \item[2\opt b.] Spieler drückt zusätzlich Schleich\-taste (Shift):
  \item[2\opt b.1.] Spiel verringert horizontale Geschwindigkeit der Spielfigur
  \item[3.] Spiel bestimmt Richtung und Geschwindigkeit der Bewegung
  \item[4.] Spiel beginnt die Position der Spielfigur anzupassen bis der Spieler die Eingabe verändert
  \item[5.] Spieler verändert die Eingabe oder lässt alle Eingaben los
  \item[6.] Use-Case endet erfolgreich
\end{description}

\subsubsection*{UC02 – Bewegen (vertikal)}

\textbf{Name:} Bewegen (vertikal) \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Vertikale Fortbewegung der Spielfigur entsprechend der Eingaben  \\
\textbf{Vorbedingungen:} Spielfigur befindet sich in der Spielwelt \\
\textbf{Nachbedingungen:} Position der Spielfigur wurde angepasst \\
\textbf{Beschreibung:} Der Spieler bewegt die Spielfigur durch Eingabe von Leertaste oder Shift. Dies funktioniert nur wenn die Spielfigur fliegt oder schwimmt.

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spiel validiert, dass Spieler im Zustand Schwimmen oder Fliegen ist
  \item[2.] Spieler drückt Leertaste
  \item[2a.] Spieler drückt Shift:
  \item[2a.1.] Spiel setzt eine Geschwindigkeit nach unten
  \item[2a.2.] Use-Case wird bei Schritt 4 fortgesetzt
  \item[3.] Spiel setzt eine Geschwindigkeit nach oben
  \item[4.] Spiel beginnt die Position der Spielfigur anzupassen bis der Spieler die Eingabe verändert
  \item[5.] Spieler verändert die Eingabe oder lässt alle Eingaben los
  \item[6.] Use-Case endet erfolgreich
\end{description}

\subsubsection*{UC03 – Springen}

\textbf{Name:} Springen \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Hindernisse überwinden oder Höhe gewinnen \\
\textbf{Vorbedingungen:} Spielfigur befindet sich in der Spielwelt \\
\textbf{Nachbedingungen:} Spielfigur bekommt Bewegung vertikal nach oben\\
\textbf{Beschreibung:} Durch Drücken der Springtaste kann die Spielfigur bei Bodenkontakt einen einmaligen Sprung ausführen.

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spiel validiert, dass Spieler im Zustand Laufen ist
  \item[1a.] Spielfigur ist in einem anderen Zustand
  \item[1a.1.] Use-Case endet erfolglos 
  \item[2.] Spieler drückt Sprungtaste (Leertaste)
  \item[3.] Spiel löst Sprungbewegung der Spielfigur aus
  \item[4.] Spiel setzt Zustand der Spielfigur zu Fallen
  \item[4.] Use-Case endet erfolgreich
\end{description}

\newpage

\subsubsection*{UC04 – Flugmodus umschalten}

\textbf{Name:} Flugmodus umschalten \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Zustand der Spielfigur zwischen Boden- und Flugmodus wechseln \\
\textbf{Vorbedingungen:} Spielfigur befindet sich in der Spielwelt \\
\textbf{Nachbedingungen:} Gravitation ist deaktiviert oder wiederhergestellt; Flugverhalten wird angepasst \\
\textbf{Beschreibung:} Durch Drücken der Flugmodus-Taste kann der Spieler zwischen normalem Bewegungsmodus und Flugmodus wechseln. Der Flugmodus deaktiviert die Gravitation und ermöglicht kontrollierte Bewegung in alle Richtungen. Beim erneuten Drücken wird der Zustand wieder zurückgesetzt.

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spiel validiert, dass Spieler im Zustand Fallen oder Fliegen ist
  \item[2.] Spieler drückt die Fliegentaste (F)
  \item[3.] Spiel aktiviert den Flugmodus für die Spielfigur
  \item[3a.] Flugmodus ist bereits aktiv
  \item[3a.1.] Spiel deaktiviert den Flugmodus für die Spielfigur
  \item[4.] Use-Case endet erfolgreich
\end{description}

\newpage

\subsubsection*{UC05 – Maussteuerung umschalten}

\textbf{Name:} Maussteuerung umschalten \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Spielsteuerung temporär deaktivieren (z.B. für Fensterwechsel) oder wieder aktivieren\\
\textbf{Vorbedingungen:} Spielsteuerung ist aktiv \\
\textbf{Nachbedingungen:} Mauszeiger ist sichtbar, Steuerung pausiert \\
\textbf{Beschreibung:} Mit einer Taste kann der Spieler zwischen Maussteuerung und normaler Cursorbewegung wechseln.

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spieler drückt Mausfreigabetaste (L)
  \item[2.] Spiel schaltet Mauszeiger frei
  \item[2a.] Mauszeiger ist bereits freigeschaltet
  \item[2a.1.] Spiel fängt den Mauszeiger ein
  \item[2a.2.] Spiel aktiviert Mausbewegung zur  Kamerasteuerung
  \item[2a.3.] Use-Case endet erfolgreich
  \item[3.] Spiel deaktiviert Mausbewegung zur Kamerasteuerung
  \item[4.] Use-Case endet erfolgreich
\end{description}

\newpage

\subsubsection*{UC06 – Block abbauen}

\textbf{Name:} Block abbauen \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Entfernen eines Blocks aus der Spielwelt \\
\textbf{Vorbedingungen:} Spielfigur ist aktiv und schaut in eine ausgewählte Blickrichtung \\
\textbf{Nachbedingungen:} Block ist nicht mehr in der Welt vorhanden \\
\textbf{Beschreibung:} Durch Mausklick kann ein Block entfernt und ggf. aufgenommen werden.

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spieler klickt die linke Maustaste
  \item[2.] Spiel validiert, dass ein entfernbarer Block im Sichtfeld ist
  \item[2a.] Es ist kein entfernbarer Block im Sichtfeld
  \item[2a.1.] Use-Case endet erfolglos
  \item[3.] Spiel entfernt Block aus der Welt
  \item[4.] Spiel fügt den Block dem Inventar der Spielfigur hinzu
  \item[4a.] Das Inventar der Spielfigur ist voll
  \item[4a.1.] Spiel fügt den Block nicht dem inventar der Spielfigur hinzu
  \item[4a.2.] Use-Case endet erfolgreich 
  \item[5.] Use-Case endet erfolgreich
\end{description}

\newpage

\subsubsection*{UC07 – Block platzieren}

\textbf{Name:} Block platzieren \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Platzieren eines Blocks an einer bestimmten Stelle \\
\textbf{Vorbedingungen:} Spielfigur ist aktiv und schaut in eine ausgewählte Blickrichtung \\
\textbf{Nachbedingungen:} Der Block ist in der Spielwelt sichtbar \\
\textbf{Beschreibung:} Spieler kann Blöcke frei setzen, um die Spielwelt zu gestalten.

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spieler wählt mit Pfeiltasten (up/down) oder Nummerntasten (1-9) einen platzierbaren Block aus seinem Inventar
  \item[1a.] Spieler hat keinen validen Block in der Hand
  \item[1a.1.] Use-Case endet erfolglos
  \item[2.] Spieler klickt die rechte Maustaste
  \item[3.] Spiel validiert, dass der Block platziert werden kann
  \item[3a.] Es ist keine valide Oberfläche im Sichtfeld
  \item[3a.1.] Use-Case endet erfolglos
  \item[4.] Spiel platziert Block an ausgewählter Stelle
  \item[5.] Spiel entfernt Block aus dem Inventar
  \item[6.] Use-Case endet erfolgreich
\end{description}

\subsubsection*{Spiel Verlassen}

Das Verlassen des Spiels ist nicht als Use-Case modelliert, da beim Verlassen des Spiels keine weiteren Aktionen vorgenommen werden, als das Programm zu beenden. Dies geschieht durch das Schlie\ss{}en des Fensters oder durch Drücken der Escape-Taste. Das Spiel wird dann beendet und alle Ressourcen werden freigegeben.

\subsection{Domänenmodell} \label{subsec:domain}

Abbildung \ref{gfx:domain} zeigt ein Domänemodell unserer Software. Es wurde basierend auf den Use Cases entworfen und enthält alle wichtigen Objekte, die die Problematik des vereinfachten Minecraft Spiels nach Au\ss{}en hin sichtbar sind, mit denen interagiert wird. 

\begin{gfx}{Domänenmodell}{domain}{ht}
\umlclass[x=11.2,y=-14.0,alias=UMLClass0,type={DatenObjekt}]{Vektor}
{
  x: Zahl \\
  y: Zahl \\
  z: Zahl \\
}
{
}
\umlclass[x=12.70,y=-4.50,alias=UMLClass1]{World}
{
}
{
  block\_entfernen(position: Vektor): Bool \\
  block\_platzieren(position: Vektor): Bool \\
}
\umlclass[x=11.20,y=-9.50,alias=UMLClass2]{Spielfigur}
{
  position: Vektor \\
  bewegung: Vektor \\
  am\_fliegen: Bool \\
}
{
  springen(): void \\
  sprinten(): void \\
  schleichen(): void \\
  fliegen(): void \\
  abbauen(): viod \\
  platzieren(): void \\
}
\umlclass[x=19.40,y=-4.50,alias=UMLClass3]{Block}
{
  block\_id: Zahl \\
  textur\_id: Zahl \\
  position: Vektor
}
{
}
\umlclass[x=18.00,y=-8.50,alias=UMLClass4]{Inventar}
{
}
{
  item\_entfernen(item\_id: Zahl): Bool \\
  item\_hinzufügen(itme\_id: Zahl): Bool \\
}
\umlclass[x=18.60,y=-14.0,alias=UMLClass5]{ItemStack}
{
  item\_id: Zahl \\
  anzahl: Zahl \\
}
{
  ahzahl\_erhöhen(): void \\
  anzahl\_verringern(): void \\
}
\umlcompo[name=Relation0,geometry=--,anchor1=0,anchor2=180,mult1={1},pos1=0.2,mult2={*},pos2=0.8]{UMLClass1}{UMLClass3}
\umlassoc[name=Relation1,geometry=--,anchor1=-146.9,anchor2=90.0,mult1={1},pos1=0.2,mult2={1},pos2=0.8]{UMLClass1}{UMLClass2}
\umlcompo[name=Relation2,geometry=--,anchor1=32.0,anchor2=180.0,mult1={1},pos1=0.2,mult2={*},pos2=0.8]{UMLClass2}{UMLClass4}
\umlaggreg[name=Relation3,geometry=--,anchor1=-59,anchor2=90,mult1={1},pos1=0.2,mult2={*},pos2=0.8]{UMLClass4}{UMLClass5}
\end{gfx}

Es ist zu sehen, wie sich die Spielfigur in einer Welt aus Blöcken befindet und sich in dieser auf verschiedene Arten bewegen kann. Die Blöcke der Welt können abgebaut und wieder platziert werden, und befinden sich zwischenzeitig als Item auf einem ItemStack in dem Inventar der Spielfigur.

\section{Meilenstein 2} \label{sec:ms2}

In Meilenstein 2 soll es darum gehen, die bevorstehenden Änderungen des Projektes zu beschreiben. Hier ebenfalls wieder in Modell- und Textform. 

\subsection{Designmodell} \label{subsec:design}

Im folgenden Abschnitt ist das Designmodell in mehrere kleinere Abschnitte unterteilt worden. Dies ist dem gro\ss{}en Umfang des Modells geschuldet. Jeder Teil des Modells ist textuell erklärt. Die Erklärungen werden durch stark vereinfachte Ausschnitte des Designmodells unterstützt. Das komplette Designmodell kann hier eingesehen werden: \href{https://github.com/lasiv/MineCraft-One-Week-Challenge/blob/master/latex/design_full.png}{Designmodell}

\subsubsection*{Application}

\begin{gfx}{States}{states}{ht}
\umlsimpleclass[x=0,y=-0.5,alias=UMLClass0]{Application}
\umlsimpleclass[x=0,y=-3.00,alias=UMLClass1]{StateBase}
\umlsimpleclass[x=0,y=-5,alias=UMLClass2]{PlayState}
\umlsimpleclass[x=-2,y=-8,alias=UMLClass3]{Player}
\umlsimpleclass[x=2,y=-8,alias=UMLClass4]{World}
\umlcompo[name=Relation0,geometry=--,mult1={1},pos1=0.2,mult2={*},arg2={states},pos2=0.8]{UMLClass0}{UMLClass1}
\umlinherit[name=Relation1,geometry=--,]{UMLClass2}{UMLClass1}
\umlcompo[name=Relation2,geometry=|-|,anchor1=-130.0,mult1={1},pos1=0.2,mult2={1},arg2={player},pos2=2.8]{UMLClass2}{UMLClass3}
\umlcompo[name=Relation3,geometry=|-|,anchor1=-50.0,mult1={1},pos1=0.2,mult2={1},arg2={world},pos2=2.8]{UMLClass2}{UMLClass4}
\umlassoc[name=Relation4,geometry=--,mult1={1},pos1=0.2,mult2={1},pos2=0.8]{UMLClass4}{UMLClass3}
\end{gfx}

Die Klasse \texttt{Application} ist die Einstiegspunkt in die Software. Sie enthält alle wichtigen Komponenten, wie den Kontext des Fensters, die Kamera, die Oberklasse für das Rendern sowie die ganzen States der Software.

Gängiges Vorgehen bei Spielen, ist sie in mehrere Zustände zu unterteilen, und diese auf einem Stapel abzulegen. Wird nun z.B. das Pause-Menü geöffnet, wird der Zustand dieses Menüs auf den Stapel gepackt. Wenn das Menü wieder geschlossen wird, wird der darunterliegende Zustand des Spiels einfach weiter geführt. Dies ist hier auch implementiert, jedoch gibt es momentan nur einen Zustand.

Der einzige Zustand, den unser Spiel momentan kennt ist der PlayState. Er enthält die Welt, den Spieler, grundlegende Konfigurationen des Spiels und eine Referenz zur Eingabe von Tasten.

\subsubsection*{Player}
\begin{gfx}{Player}{player-design}{ht}
\umlsimpleclass[x=15.90,y=-8.30,alias=UMLClass0]{Player}
\umlsimpleclass[x=16.00,y=-6.30,alias=UMLClass1]{Entity}
\umlsimpleclass[x=20.80,y=-6.30,alias=UMLClass2]{AABB}
\umlsimpleclass[x=15.90,y=-10.90,alias=UMLClass3]{ItemStack}
\umlsimpleclass[x=15.90,y=-13.50,alias=UMLClass4]{Material}
\umlsimpleclass[x=12.40,y=-6.30,alias=UMLClass5]{PlayState}
\umlinherit[name=Relation0,geometry=--,anchor1=71.6,anchor2=-90.0]{UMLClass0}{UMLClass1}
\umlcompo[name=Relation1,geometry=--,anchor1=-4.1,anchor2=-175.9]{UMLClass1}{UMLClass2}
\umlcompo[name=Relation2,geometry=--,anchor1=-71.6,anchor2=71.6,mult1={1},pos1=0.2,mult2={*},arg2={items},pos2=0.8]{UMLClass0}{UMLClass3}
\umlassoc[name=Relation3,geometry=--,anchor1=-71.6,anchor2=71.6,mult1={1},pos1=0.2,mult2={1},arg2={material},pos2=0.8]{UMLClass3}{UMLClass4}
\umlcompo[name=Relation4,geometry=|-,anchor1=-90.0,anchor2=-177.3,mult1={1},pos1=0.2,mult2={1},arg2={player},pos2=1.8]{UMLClass5}{UMLClass0}
\end{gfx}

Die \texttt{Player} Klasse stellt eine Schnittstelle für den Benutzer dar, mit dem Spiel zu interagieren und ist von der Klasse \texttt{Entity} abgeleitet. Sie enthält eine Axis Aligned Bounding Box (\texttt{AABB}) um Kollisionen in der Welt wahrzunehmen. Der \texttt{Player} ist Teil der Klasse \texttt{PlayState} und hat somit auch Zugriff auf die  Events vom \texttt{Keyboard}. In der Spielerklasse werden die Tastatureingaben zum bewegen in der Welt verarbeitet, sowie die Mausbewegungen, um sich bewegen und umschauen zu können. Weitere Interaktionen beinhalten beispielsweise das Abbauen und Platzieren von Blöcken in der Welt. Baut der Spieler einen Block ab, so wird er als Item, mit spezifischen Material, in der Klasse \texttt{ItemStack} gespeichert. 

\FloatBarrier
\subsubsection*{World}

\begin{gfx}{World}{world}{ht}
  \umlsimpleclass[x=14.40,y=-13.80,alias=UMLClass0]{Player}
  \umlsimpleclass[x=17.90,y=-10.80,alias=UMLClass1]{World}
  \umlsimpleclass[x=14.40,y=-10.80,alias=UMLClass2]{PlayerDigEvent}
  \umlsimpleclass[x=14.40,y=-8.60,alias=UMLClass3,type={interface}]{IWorldEvent}
  \umlsimpleclass[x=22.30,y=-8.60,alias=UMLClass4]{ChunkManager}
  \umlsimpleclass[x=22.40,y=-10.80,alias=UMLClass5]{Chunk}
  \umlsimpleclass[x=22.50,y=-13.80,alias=UMLClass6]{ChunkSection}
  \umlsimpleclass[x=22.50,y=-16.30,alias=UMLClass7]{ChunkBlock}
  \umluniassoc[name=Relation0,geometry=|-,anchor1=150.3,anchor2=0.0,mult1={1},pos1=0.2,mult2={*},arg2={events},pos2=1.6]{UMLClass1}{UMLClass3}
  \umlinherit[name=Relation1,geometry=--,anchor1=90.0,anchor2=-90.0]{UMLClass2}{UMLClass3}
  \umluniassoc[name=Relation2,geometry=--,anchor1=-90.0,anchor2=90.0,mult1={*},arg1={pPLayer},pos1=0.2,mult2={1},pos2=0.8]{UMLClass2}{UMLClass0}
  \umlassoc[name=Relation3,geometry=|-,anchor1=-150.3,anchor2=0.0,mult1={1},pos1=0.2,mult2={1},pos2=1.8]{UMLClass1}{UMLClass0}
  \umluniassoc[name=Relation4,geometry=--,anchor1=180.0,anchor2=0.0,mult1={*},arg2={/pWorld},pos1=0.1,mult2={1},pos2=0.7]{UMLClass5}{UMLClass1}
  \umlcompo[name=Relation5,geometry=|-,anchor1=29.7,anchor2=180.0,mult1={1},arg1={world},pos1=0.2,mult2={1},arg2={chunkManager},pos2=1.5]{UMLClass1}{UMLClass4}
  \umlassoc[name=Relation6,geometry=|-,anchor1=-29.7,anchor2=180.0,mult1={1},arg1={pWorld},pos1=0.2,mult2={*},arg2={chunkUpdates},pos2=1.55]{UMLClass1}{UMLClass6}
  \umluniassoc[name=Relation7,geometry=--,anchor1=-76.0,anchor2=90.0,mult1={1},pos1=0.2,mult2={*},arg2={chunks},pos2=0.8]{UMLClass4}{UMLClass5}
  \umlcompo[name=Relation8,geometry=--,anchor1=-90.0,anchor2=104.0,mult1={1},pos1=0.2,mult2={*},arg2={chunks},pos2=0.8]{UMLClass5}{UMLClass6}
  \umlaggreg[name=Relation9,geometry=--,anchor1=-90.0,anchor2=90.0,mult1={1},pos1=0.2,mult2={*},arg2={blocks},pos2=0.8]{UMLClass6}{UMLClass7}
\end{gfx}

Im Zentrum des Spiels steht die \texttt{World} Klasse. Diese ist in Chunks unterteilt, die jeweils mehrere ChunkSections definieren, in denen die Blöcke der Welt gespeichert sind. Mithilfe des Chunkmanagers werden die Chunks generiert bzw. verwaltet. Sobald diese Blöcke, die dem Chunk angehören, abgebaut werden sollen, löst dies ein \texttt{PlayerDigEvent} aus. Dieses sorgt dafür, dass der Block tatsächlich aus der Welt verschwindet bzw. wieder auftaucht. Sobald eine Welt instanziiert wird, startet ein neuer Thread welcher für die Generierung von Chunks verantwortlich ist. Damit kann das Rendern unabhängig von der Generierung vonstatten gehen und die beiden Prozesse stehen sich nicht im Weg. 

\FloatBarrier
\subsubsection*{Blöcke}

\begin{gfx}{Blöcke}{blocks}{ht}
\umlclass[x=13.60,y=-12.40,alias=UMLClass0,type={NonCopyable}]{BlockDataHolder}
{
  id : BlockId \\
  isOpaque : bool \\
  isColidable : bool \\
  bounce : float \\
  slip: int \\
}
{
}
\umlclass[x=8.20,y=-7.90,alias=UMLClass1]{ChunkBlock}
{
  getData() : BlockDataHolder \\
  getType() : BlockType \\
}
{
  id : Block\_t \\
}
\umlclass[x=13.70,y=-3.60,alias=UMLClass2,type={NonCopyable}]{BlockType}
{
}
{
  getData() : BlockData \\
}
\umlclass[x=13.70,y=-7.80,alias=UMLClass3,type={NonCopyable}]{BlockData}
{
}
{
  getBlockData() : BlockDataHolder \\
}
\umlclass[x=7.80,y=-3.60,alias=UMLClass4,type={Signleton}]{BlockDatabase}
{
}
{
  \umlstatic{get() : BlockDatabase} \\
  getData() : BlockData \\
  getBlock() : BlockType \\
}
\umluniassoc[name=Relation0,geometry=|-,anchor1=-102.5,anchor2=164.1,mult1={*},pos1=0.2,mult2={1},pos2=1.8]{UMLClass1}{UMLClass0}
\umluniassoc[name=Relation1,geometry=|-|,anchor1=90.0,anchor2=-132.0,mult1={*},pos1=0.2,mult2={1},pos2=2.8]{UMLClass1}{UMLClass2}
\umlcompo[name=Relation2,geometry=--,anchor1=-95.7,anchor2=95.7,mult1={1},pos1=0.2,mult2={1},arg2={data},pos2=0.8]{UMLClass2}{UMLClass3}
\umlcompo[name=Relation3,geometry=--,anchor1=-95.7,anchor2=90.0,mult1={1},pos1=0.2,mult2={1},arg2={data},pos2=0.8]{UMLClass3}{UMLClass0}
\umlcompo[name=Relation4,geometry=--,anchor1=0.0,anchor2=180.0,mult1={1},pos1=0.2,mult2={*},arg2={blocks},pos2=0.8]{UMLClass4}{UMLClass2}
\end{gfx}

Die Blöcke selber enthalten Daten über ihre Eigenschaften. Sie speichern nicht ihre eigene Position. Die Eigenschaften der Blöcke werden aus Dateien geladen, die zentral in einer Art Datenbank gespeichert sind. Die Chunk-Blöcke enthalten Verweise auf diese Daten.

\FloatBarrier
\subsubsection*{Generierung}

\begin{gfx}{Generation der Welt}{genreation}{ht}
\umlsimpleclass[x=5.90,y=-1.80,alias=UMLClass0]{World}
\umlsimpleclass[x=9.20,y=-7.40,alias=UMLClass1]{Chunk}
\umlsimpleclass[x=9.10,y=-4.40,alias=UMLClass2]{ChunkManager}
\umlsimpleclass[x=6.80,y=-9.60,alias=UMLClass3]{StructureBuilder}
\umlsimpleclass[x=13.20,y=-8.20,alias=UMLClass4]{ClassicOverworldGenerator}
\umlsimpleclass[x=7,y=-12.80,alias=UMLClass5]{Biome}
\umlsimpleclass[x=14.05,y=-12.80,alias=UMLClass6]{NoiseGenerator}
\umluniassoc[name=Relation0,geometry=-|,anchor1=180.0,anchor2=-104.0,mult2={1},arg2={pWorld},pos1=0.2,mult1={*},pos2=1.9]{UMLClass1}{UMLClass0}
\umlcompo[name=Relation1,geometry=-|,anchor1=0.0,anchor2=76.0,mult1={1},arg1={world},pos1=0.2,mult2={1},arg2={chunkManager},pos2=1.8]{UMLClass0}{UMLClass2}
\umluniassoc[name=Relation2,geometry=--,anchor1=-76.0,anchor2=90.0,mult1={1},pos1=0.2,mult2={*},arg2={chunks},pos2=0.8]{UMLClass2}{UMLClass1}
\umldep[name=Relation3,geometry=-|,anchor1=180.0,anchor2=-116.6]{UMLClass5}{UMLClass3}
\node[left] at (Relation3-3) {$\ll$uses$\gg$};
\umlcompo[name=Relation4,geometry=-|,anchor1=0.0,anchor2=90.0,mult1={1},pos1=0.2,mult2={1},arg2={terrainGenerator},pos2=1.8]{UMLClass2}{UMLClass4}
\umlcompo[name=Relation5,geometry=--,anchor1=-26.6,anchor2=104.0,mult1={1},pos1=0.2,mult2={1},arg2={biomeNoiseGen},pos2=0.8]{UMLClass4}{UMLClass6}
\umlcompo[name=Relation6,geometry=|-|,anchor1=-153.4,anchor2=45.0,mult1={1},pos1=0.2,mult2={5},pos2=2.8]{UMLClass4}{UMLClass5}
\umlcompo[name=Relation7,geometry=--,anchor1=0.0,anchor2=180.0,mult1={1},pos1=0.2,mult2={1},arg2={heightGenerator},pos2=0.7]{UMLClass5}{UMLClass6}
\end{gfx}

Hauptverantwortlich für die Generierung der Welt ist die \texttt{TerrainGenerator} Klasse. Von der gibt es zwei Unterklassen, wovon jedoch nur eine benutzt wird, und zwar die \texttt{ClassicOverworldGenerator} Klasse. Sie ist verantwortlich für das Erstellen der ''Biomkarte'' um die Welt in verschiedene Biome zu unterteilen, die Generierung der ''Höhenkarte'' um die Oberfläche der Welt zu definieren, und für das platzieren von Vegetation wie kleine Pflanzen, Bäume und Kakteen.

Die Biomkarte und Höhenkarte werden durch eine Rauchfunktion erstellt, welches eine organisch aussehende Welt mit Hügeln, Bergen und Ozeanen erstellen lässt. Die Vegetation wird durch einfache pseudo-zufällige Zahlengenerierung platziert.

\FloatBarrier
\subsubsection*{Rendering}

Das Rendering des Spiels ist eine komplexe Angelegenheit, und wird von uns im Laufe unseres Projekts nicht verändert. Aufgrund der Komplexität ist es auch nicht vollständig modelliert, soll dennoch hier etwas genauer erklärt werden.

\begin{gfx}{Rendering von Chunks}{render}{ht}
\umlsimpleclass[x=4.20,y=-3,alias=UMLClass0]{Chunk}
\umlsimpleclass[x=4.20,y=-1,alias=UMLClass1,type={interface}]{IChunk}
\umlsimpleclass[x=10.10,y=-7.40,alias=UMLClass2]{ChunkMeshCollection}
\umlsimpleclass[x=10.10,y=-10.00,alias=UMLClass3]{ChunkMesh}
\umlsimpleclass[x=11.60,y=-12.5,alias=UMLClass4]{Mesh}
\umlsimpleclass[x=8.60,y=-12.5,alias=UMLClass5]{Model}
\umlsimpleclass[x=4.60,y=-5.60,alias=UMLClass6]{ChunkSection}
\umlsimpleclass[x=10.10,y=-3.80,alias=UMLClass7]{ChunkMeshBuilder}
\umlsimpleclass[x=4.60,y=-8.60,alias=UMLClass8]{ChunkBlock}
\umlimpl[name=Relation0,geometry=--,anchor1=90.0,anchor2=-90.0]{UMLClass0}{UMLClass1}
\umldep[name=Relation1,geometry=|-,anchor1=36.0,anchor2=180.0]{UMLClass6}{UMLClass7}
\node[above] at (Relation1-3) {$\ll$uses$\gg$};
\umlcompo[name=Relation2,geometry=|-,anchor1=-160.0,anchor2=5.0,mult1=1,mult2=1,pos2=1.9,pos1=0.3]{UMLClass7}{UMLClass6}
\umlcompo[name=Relation3,geometry=--,mult1=1,mult2=1]{UMLClass7}{UMLClass2}
\umlcompo[name=Relation4,geometry=|-,anchor1=-36,anchor2=180.0,mult1=1,mult2=1,pos2=1.9,pos1=0.3]{UMLClass6}{UMLClass2}
\umlcompo[name=Relation5,geometry=--,anchor2=136,mult1=1,mult2={*}]{UMLClass0}{UMLClass6}
\umlcompo[name=Relation6,geometry=--,mult1=1,mult2=3,arg2={solid, water, flora}]{UMLClass2}{UMLClass3}
\umlcompo[name=Relation7,geometry=--,mult1=1,mult2=1, pos2=0.7]{UMLClass3}{UMLClass4}
\umlcompo[name=Relation8,geometry=--,mult1=1,mult2=1, pos1=0.3]{UMLClass3}{UMLClass5}
\umlcompo[name=Relation9,geometry=--,anchor1=-136,anchor2=136.0,mult1=1,mult2={*}]{UMLClass6}{UMLClass8}
\end{gfx}

Die Application hat eine Referenz zum sog. RenderMaster, die von der Application zu den jeweiligen Klassen weitergereicht wird, die diesen benutzen wollen. Dabei werden hier hauptsächlich nur die Einzelnen Chunks und die Skybox mit Model und Mesh versehen, und vom Renderer dargestellt. Abbildung \ref{gfx:render} zeigt den groben Aufbau von Modell und Mesh in einem Chunk, ist in dieser Form aber nicht im Gesamtmodell mit drin.

\FloatBarrier
\subsubsection*{Input}

Der Input erfolgt wie im nächstem Abschnitt beschrieben über die externe Bibliothek \texttt{SFML}. Es werden zwei Klassen definiert, die an verschiedenen Stellen im Projekt verwendet werden. Einmal eine \texttt{Keyboard} Klasse, die alle zur Zeit gedrückten Tasten als Boolean werte speichert. Eine weitere Klasse \texttt{ToggleKey}, die eine bestimmte Taste softwareseitig entprellt, um sie als Schalter nutzen zu können.

\subsubsection*{Dependencies}

Unser Projekt benutzt verschiedene Bibliotheken, die oft in solchen \texttt{C++} Projekten vorkommen. Für komplexere Rechnungen zieht der Programmierer hier \texttt{GLM} heran. Davon benutzt das Programm unterschiedlichen Vektoren, Materialien und Matrizen oder wird für z.B. Strahlenrechnung benutzt.

Die Bibliothek \texttt{SFML} ermöglicht die Erstellung von Fenstern in denen das Spiel angezeigt wird, unterstützt Eingabeerkennung z.B. für die Klassen Keyboard und ToggleKey und kann später für UI Elemente genutzt werden.

\texttt{Glad} ist die Bibliothek, die das Rendern mit OpenGL übernimmt und wird in den Render Klassen aufgerufen, um mithilfe der Meshes, Modelle und Shadern das Spiel darzustellen.

\subsection{Zustandsmodell} \label{subsec:statemodel}

In unserem Projekt bietet sich nicht an, Zustandsdiagramme zu erstellen. Viele Prozesse laufen sehr statisch ab und würden in zu simplen Zustandsdiagrammen resultieren.

\subsection{Beschreibung der geforderten Veränderungen} \label{subsec:desc_of_changes}

Hiermit wird beschrieben, inwiefern sich die geplanten Veränderungen im Projekt äu\ss{}ern. Dies geschieht im Bezug auf den in Abschnitt \ref{subsec:inf} beschriebenen Zustand des Projektes. Es soll damit deutlich werden, dass die Software nicht von Grund neu gedacht wird. Es entstehen mehr oder weniger Add-On artige Veränderungen.

Bei den Hauptthemen der Änderungen geht es vor allem um einen grafische Benutzeroberfläche, die Änderung von Bewegungsabläufen und der Physik und die Generierung von Strukturen.

\subsubsection{Code}

Neben den tatsächlichen Änderungen, steht eine Aufgabe an erster Stelle. Der Programmierer diese Projekts hat einige Funktionen, die letztenendes doch nicht benutzt werden, im Code stehen lassen. Deswegen versuchen wir zuerst unbenutzte Klassen und Codebereiche ''aufzuräumen'' bevor wir mit unseren Änderungen anfangen.

\subsubsection{GUI \& Logik}

Der aktuelle Zustand der Benutzeroberfläche ist quasi nicht existent. Denn es ist noch nicht wirklich eine Oberfläche vorhanden. Dies macht die Verwendung von der Software sperrig und unnötig schwerer. Dahingehend ist geplant, dass die Bedienung deutlich einfacher wird, indem an verschiedenen Stellen eine grafische Oberfläche implementiert wird.

Genau Verändern soll sich folgendes:

\begin{description}
  \item[Inventarsystem:] Das Inventar wird ersichtlich. Durch eine Schnellzugriffsleiste und zusätzliches Inventar durch drücken einer Taste wird das Verwalten von Gegenständen im Inventar stark vereinfacht.
  \item[Fadenkreuz:] Das Fadenkreuz dient dem Spieler dazu genau zu sehen, welches Objekt gerade exakt anvisiert wird. Dies erleichtert dem Spieler die Kontrolle über die Veränderung der Spielwelt.
  \item[Lebensanzeige:] Die Lebensanzeige zeigt dem Spieler an, wann die Spielfigur einen Reset (Tod) erleben wird. Im Zuge dessen wird auch die Eigenschaft entstehen, dass die Spielfigur schaden in Form von Fallschaden nehmen kann.
  \item[Kompass:] Der Kompass zeigt dem Spieler während des Spiels an in welche Richtung geschaut wird, was enorm zur Orientierung in der Spielwelt beiträgt.
\end{description}

\subsubsection{Movement/Physik}

Anpassung der Bewegung
Schleichen kanten
Schleimblöcke
Block Slipperyness Werte
Schwimmen

Der Minecraft Klon bietet bereits ein grundlegendes Bewegungssystem des Spielers. Es fehlen jedoch noch einige weiteren Features, die im Basisspiel enthalten sind und auch einige zusätzliche Spielereien, um das Erlebnis etwas spannender zu machen. Auch soll die existierende Berechnung der Position etwas angepasst werden, da sich die Steuerung mit aktueller Bewegung nicht intuitiv anfühlt

Folgende Änderungen sollen folgen:

\begin{description}
  \item[Anpassung der Berechnung:] Die aktuelle Berechnung ist recht rudimentär und kann noch etwas Finetuning vertragen, damit sich die Bewegung flüssiger anfühlt. Au\ss{}erdem eröffnet das Möglichkeiten die Bewegung besser mit anderen Features zu Kombinieren.
  \item[Schleichen:] Im normalen Spiel bietet das Schleichen die besondere Fähigkeit, an die Kante von Blöcken zu laufen und nicht herunterzufallen. Dieses Feature ist hier noch nicht umgesetzt. Es soll ermöglichen dem Spieler mehr Sicherheit zu geben.
  \item[Schwimmen:] Wasserblöcke im Basisspiel sind recht kompliziert, wie sie sich ausbreiten können. In diesem Spiel gibt es aufgrund der einfachen Generierung ein festes Wasserlevel. Wenn man dieses unterschreitet und sich im Wasser befindet, läuft man aber einfach normal unter der Wasseroberfläche weiter. Das soll sich ändern, damit man über die Seen der Welt hinweg schwimmen kann und nicht in ihnen versinkt.
  \item[Slipperiness:] Verschiedene Blöcke können im Basisspiel verschiedene Beschaffenheiten haben. So beginnt man auf Eis zu rutschen und in bestimmten Sandarten stecken zu bleiben, bzw langsamer voranzukommen. Dies kann mithilfe von Oberflächenbeschaffenheit in die neue Berechnung mit einbezogen werden.
  \item[Schleimblöcke:] Der Schleimblock hat die Eigenschaft elastisch auf den Fall des Spielers zu reagieren und ihn wieder hochzuschleudern. Diese Mögliche Eigenschaft eines Blockes den Spieler wieder hochzuwerfen soll ebenfalls mit in die Bewegungsgleichung einflie\ss{}en.
\end{description}

\subsubsection{Generierung von Strukturen}

Aktuell gibt es nur wenig Code, der für die Generierung von Strukturen
verantwortlich ist. Es gibt eine Klasse, welche Strukturen in der Welt platziert
und eine zum erstellen von ''Multi-Block'' Vegetation wie Kakteen oder Bäume.
Diese Strukturen sind jedoch hart in den Code eingebaut, und es gibt nur wenig
Variation zwischen einzelnen Strukturen. Auch ist es der aktuellen Architektur
unmöglich, Chunk übergreifende Strukturen zu bauen: diese sind dann an den
Chunkgrenzen abgehackt. Daher soll der Strukturgenerierungscode um folgende
Punkte erweitert werden:

\begin{itemize}
	\item Laden und halten des Aufbaus einer Struktur
	\item Generieren der Struktur, ggf. angepasst an das Terrain (z.B. Stra\ss{}en,
	die der Wölbung des Bodens folgen)
	\item Logik implementieren für ''Puzzle'' Strukturen, bei der mehrere Teile
	ineinander passen
	\item Chunk übergreifende Strukturen
\end{itemize}

\iffalse
\subsubsection{Speichersystem}

Ein weiteres Problem, dass bei verbleibender Zeit gelöst werden könnte, ist das Speichersystem. Momentan werden jegliche Änderungen und den Blockkonfigurationen der Chunks verworfen, wenn der Chunk entladen wird. Wird er neu geladen wird er neu generiert und die Änderungen gehen verloren. 

Folgende Änderungen können hier getätigt werden:

\begin{description}
  \item[Speichern bei Laufzeit:] Die erste Funktion wäre herauszufinden, wie die Änderungen platz-effizient gespeichert werden könnten, und wie man sie dann während des Spiels speichern und laden kann
  \item[Speichern und Laden nach Laufzeit:] Weiterführend kann man diese Änderungen auch als Datei speichern, sodass nach Beendung des Spiels die gespeicherte Welt wieder geöffnet werden kann. Dies braucht dann einige zusätzliche Features der Bedienung.
  \item[Weltauswahl:] Eine Möglichkeit wäre, im Zuge der Änderungen an UI eine Art Auswahl-Menü zu bauen, in der Welten generiert und gestartet werden können.
\end{description}
\fi

\section{Meilenstein 3} \label{sec:ms3}

Schwerpunkt von Meilenstein 3 ist das Aufzeigen der tatsächlichen Veränderungen. Abschließend wurde ein Fazit verfasst, welches unter anderem auf Probleme oder Vorgehensweisen eingeht. Zunächst werden die Veränderungen beschrieben und anschließend im Domänenmodell in den Kontext gesetzt. Dabei wird nicht das ganze Domänenmodell erneut modelliert, sondern die im Kontext wichtigen Klassen und Beziehungen veranschaulicht.

\subsection{Beschreibung der Änderungen}

Im folgenden Abschnitt werden die Umsetzungen bzw. die tatsächlichen Änderungen beschrieben.

\subsubsection{Strukturen und Weltgenerierung}

Vor der Änderung waren die Biome selber für die Generierung ihrer Strukturen verantwortlich, zu dem Zeitpunkt ausschließlich Bäume. Dies wurde mit der erweiterten Version geändert: Der Terraingenerator fragt lediglich die Biome, welche Art von Strukturen und Vegetation in ihnen auftauchen und der Terraingenerator ist verantwortlich für die Generierung. Auch wurden die Fähigkeiten des Generators erweitert: Vorher wusste er nur von der Höhen- und Biomverteilung über den Chunk Bescheid, den er gerade bearbeitet. Dadurch war es unmöglich Teile von Strukturen zu generieren, deren Zentrum zwar außerhalb des Chunks waren aber in den aktuellen Chunk rein ragten. Der neue Code verbessert dies: Es wird nun die Höhen- und Biomverteilung von den direkt und vertikal angrenzenden Chunks generiert, sodass die sich dort befindlichen Strukturen ermittelt und die in den Chunk ragenden Teile platziert werden können. Zu guter letzt gibt es nun die Möglichkeit, neue Strukturen mithilfe von Dateien zu beschreiben, anstatt diese starr im Code definieren zu müssen. Zwar müssen neue Typen von Strukturen immernoch in den Code integriert werden, indem ihre ID an den Terraingenerator übergeben wird, was jedoch einen kleineren Aufwand darstellt als die Struktur komplett im Code zu definieren.

\subsubsection{Movement}


Die Änderungen an der Bewegung des Spielers bringen wenig Änderungen am Model mit sich, es handelt sich hier hauptsächlich um Anpassungen der Algorithmen. Die erste und wichtigste Änderung, war die Anpassung und Optimierung der Bestimmung der Kollisionen der Spielfigur. Hierbei wird ein kleines Hilfsobjekt initialisiert, dass die Position der Bounding-Box festhält, diese bewegen kann und die Blöcke um sie herum aus dem Objekt der Welt lädt. Dies dient hier lediglich der Leserlichkeit. In diese modifizierte Kollision kann nun die Prüfung der Überschreitung von Kanten beim Schleichen mit eingebettet werden. 

Die Bewegung der Spielfigur selber hat sich signifikant geändert, trägt aber keine Änderung des Modells mit sich. Ursprünglich arbeitete der Klon mit einem Delta, also der Zeit, die ein Frame gebraucht hat um angezeigt zu werden. Das Originalspiel nutzt jedoch ein Ticksystem, also 20 feste Änderungen der Position pro Sekunde. Diese Formeln sind im Parkour Wiki des Spiels zu finden\footnote{\url{https://www.mcpk.wiki/wiki/Movement_Formulas}}, sie sind rekursive und daher schlecht umstellbar in andere Zeitabstände. Als Lösung wird die Position zwischen diesen Ticks interpoliert. Der erste Ansatz dafür war die Nutzung linearer Interpolation. Diese ist jedoch sehr ungenau, wenn es zu großen Änderungen bei der Geschwindigkeit kommt, zum Beispiel bei Kollisionen. Der genutzte Ansatz ist die Interpolation unter Nutzung einer Bezierkurve. Sie ermöglicht eine deutlich glattere Bewegung der Spielfigur ist aber weniger effizient in der Berechnung. Eine Bézierkurve ist eine mathematisch definierte, glatte Kurve, die durch sogenannte Kontrollpunkte beeinflusst wird. Abbildung~\ref{pic:bezier} zeigt ein Beispiel, wie eine Kubische Bezierkurve zum langsamen Anlaufen oder Abflachen einer Bewegung genutzt werden könnte. Dabei werden die Kontrollpunkte der Bezierkurve entlang einer diagonalen so gewählt, dass sich eine lineare oder an oder auslaufende Bewegung ergeben.

\begin{figure} [ht]
  \centering
  \includegraphics[width=.5\linewidth]{bezier.png}
  \caption{Bezier Kurve}
  \label{pic:bezier}
\end{figure}

Für die Berechnung der Haftung auf einem Block, sowie die elastische Rückstoß nach einem Fall auf einen Block wurde die Konfigurationsdateien und Objekte um einige Felder erweitert. Das Feld \texttt{slip} (Slipperiness) drückt aus, wie stark die Spielfigur auf dem Block rutscht, also die Fähigkeit zu beschleunigen und abzubremsen. Das Feld \texttt{bounce} gibt das Verhältnis an Geschwindigkeit an, das nach dem Aufprall wieder zurückgegeben wird. Diese Felder werden mit den anderen Daten nun aus den Dateien der Blöcke ausgelesen, in der Blockdatenbank gespeichert und können zur Berechnung der Bewegung durch den Spieler abgerufen werden.

Die letzte Änderung sollte das Problem lösen, dass das Abbauen von Blöcken unter Umständen den falschen Block entfernt. Dabei wurde der Algorithmus zum Raycasting in die Blickrichtung des Spielers angepasst. Vorher wurde der Strahl des Blicks der Spielfigur in kleinen iterativen Schritten geprüft. Das führte aber zu Situationen, an denen der Strahl zwischen zwei soliden Blöcken hindurch drang. Der neue Algorithmus nennt sich Digital Differential Analyser (DDA) der intelligenter die Schritte bis zu den Grenzen des Rasters abschätzt, und so keine Blöcke überspringen kann. Abbildung~\ref{pic:dda} zeigt dazu ein Vergleich der Beiden Methoden, sowie das aufgetretene Problem.

\begin{figure} [ht]
  \centering
  \includegraphics[width=1\linewidth]{dda.png}
  \caption{DDA Algorithmus Visualisierung}
  \label{pic:dda}
\end{figure}

\FloatBarrier

\subsubsection{GUI und Inventar}

Im Zuge der geforderten Veränderungen der grafischen Benutzeroberfläche und des Inventars, wurden die folgenden Änderungen umgesetzt.

\begin{description}
  \item[Inventarsystem:] Das \texttt{Inventar} ist grundsätzlich eine neu eingebaute Klasse, welche dem \texttt{Player} angehört. Sie ist dazu fähig, das Inventar selbständig nach bestimmtem Schema aufzufüllen und dieses zu verwalten. Es lag bereits eine sehr grobe Art eines Inventars vor, welches die Items direkt über die Klasse \texttt{ItemStack} verwaltet hat. \texttt{Inventory} verfügt nun über diese Stacks und verwaltet die Items des Spielers zentral. Dabei können Items maximal die Anzahl 64 pro Inventarslot annehmen. Sollten trotzdem weitere Einheiten des selben Items hinzugefügt werden, gehen diese in einen neuen Slot über.
  \item[Inventar Grafik:] Das Zeichnen des Inventars übernimmt teils die Klasse \linebreak[4]\texttt{Player}, und teils die Klasse \texttt{Inventory} selbst. Mithilfe der Bibliothek \texttt{SFML} können Rechtecke gezeichnet und bearbeitet werden, welche das Inventar repräsentieren. Hinzu kommt hierbei jedoch das selbstständige Verwalten des Zeichnens über den Grafiktreiber \texttt{OpenGL}. Durch das teilweise zeichnen aus der Klasse \texttt{Player} wird auf das Fenster zugegriffen, welches vorerst von der Klasse \texttt{Context} initialisiert wird. Das Anzeigen der Anzahl im Stack wird durch Zugriff auf das Inventar des Spielers möglich gemacht. Für jedes Material wird auch ein von Hand gezeichnetes Icon angezeigt.
  \item[Fadenkreuz:] Das Fadenkreuz ist ein von \texttt{SFML} gezeichneter Kreis, welcher sich in der Mitte des Fensters befindet. Dieser wird in der Klasse \texttt{Player} gezeichnet, weil auch hier wieder der Zugriff auf das Fenster nötig ist. Damit ist eine hohe Präzison beim Zerstören oder Platzieren von Blöcken möglich.
  \item[Kompass:] Beim Kompass handelt es sich um ein Nebenprodukt des Debuggens. Die Klasse \texttt{Player} enthält viele Daten, welche wichtig zur Berechnung der Bewegungen sind. Eine von diesen ist die Blickrichtung, welche mittels Maus verändert wird. Die Blickrichtung wird durch drücken der Taste F3, welche die Debuginformationen anzeigt, ersichtlich. 
\end{description}

Abschließend ist festzustellen, dass hauptsächlich die Klasse \texttt{Inventory} komplett neu ist. Klassen wie \texttt{Player} und \texttt{Context} mussten zwar verändert werden, bleiben aber in ihrer Funktionalität unverändert. Für die Grafik ist hauptsächlich die Bibliothek \texttt{SFML} wichtig.

\subsection{Modelle gemä\ss{} der Veränderungen}

In diesem Abschnitt werden Modelle um wichtige Klassen oder Beziehungen ergänzt bzw. erklärend verändert.

\subsubsection{Strukturen und Weltgenerierung}

\begin{gfx}{Caption}{tag}{ht}
\umlsimpleclass[x=11.30,y=-11.80,alias=UMLClass0]{World}
\umlsimpleclass[x=14.60,y=-14.60,alias=UMLClass1]{Chunk}
\umlsimpleclass[x=14.50,y=-11.80,alias=UMLClass2]{ChunkManager}
\umlsimpleclass[x=21.60,y=-11.80,alias=UMLClass3]{ClassicOverworldGenerator}
\umlsimpleclass[x=21.50,y=-9.20,alias=UMLClass4]{Biome}
\umlsimpleclass[x=27.90,y=-11.80,alias=UMLClass5]{NoiseGenerator}
\umlsimpleclass[x=21.60,y=-14.80,alias=UMLClass6]{Structure}
\umluniassoc[name=Relation0,geometry=-|,anchor1=180.0,anchor2=-104.0,mult1={1},arg1={pWorld},pos1=0.2,mult2={*},pos2=1.8]{UMLClass1}{UMLClass0}
\umlcompo[name=Relation1,geometry=--,anchor1=104.0,anchor2=76.0,mult1={1},arg1={world},pos1=0.2,mult2={1},arg2={chunkManager},pos2=0.8]{UMLClass0}{UMLClass2}
\umluniassoc[name=Relation2,geometry=--,anchor1=-76.0,anchor2=90.0,mult1={1},pos1=0.2,mult2={*},arg2={chunks},pos2=0.8]{UMLClass2}{UMLClass1}
\umlcompo[name=Relation3,geometry=--,anchor1=0.0,anchor2=180.0,mult1={*},pos1=0.2,mult2={1},arg2={terrainGenerator},pos2=0.8]{UMLClass2}{UMLClass3}
\umlcompo[name=Relation4,geometry=--,anchor1=0.0,anchor2=180.0,mult1={1},pos1=0.2,mult2={1},arg2={biomeNoiseGen},pos2=0.8]{UMLClass3}{UMLClass5}
\umlcompo[name=Relation5,geometry=--,anchor1=90.0,anchor2=-76.0,mult1={*},pos1=0.2,mult2={5},pos2=0.8]{UMLClass3}{UMLClass4}
\umlcompo[name=Relation6,geometry=-|,anchor1=0.0,anchor2=76.0,mult1={1},pos1=0.2,mult2={1},arg2={heightGenerator},pos2=1.8]{UMLClass4}{UMLClass5}
\umlcompo[name=Relation7,geometry=--,anchor1=-90.0,anchor2=90.0,mult1={1},pos1=0.2,mult2={*},pos2=0.8]{UMLClass3}{UMLClass6}
\end{gfx}

\FloatBarrier

\subsubsection{Movement}

Um die Lesbarkeit und Struktur des Codes zu verbessern, verwendet die Klasse \texttt{Player} eine lokal definierte Hilfsklasse \texttt{LocalAABB}.  Diese dient als temporäre Repräsentation der Bounding Box, berechnet aus Position, Dimension und Geschwindigkeit, ohne die Spielfigur selbst zu verändern. Sie speichert Transformationen lokal, lädt umgebende Blöcke zur Kollisionsprüfung und stellt berechnete Werte wie Minimum und Maximum der Bounding Box unter klar benannten Attributen bereit. Dadurch wird der eigentliche Code zur Bewegungs- und Kollisionserkennung strukturierter und leichter verständlich. Abbildung~\ref{gfx:localaabb} veranschaulicht die Rolle dieser Hilfsklasse im Zusammenspiel mit dem Spieler und den umgebenden Blöcken.

\begin{gfx}{Local Bounding Box}{localaabb}{ht}
\umlclass[x=0,y=0,alias=UMLClass0]{Player}
{
   
}{

}
\umlclass[x=0,y=4,alias=UMLClass1]{Entity}
{
  position: vec3 \\
  rotation: vec3 \\
  velocity: vec3
}{

}
\umlclass[x=6,y=4,alias=UMLClass2]{AABB}
{
  /position: vec3 \\
  dimensions: vec3
}{
  update(location: vec3)
}
\umlclass[x=6,y=0,alias=UMLClass3]{LocalAABB}
{
  position: vec3 \\
  /min: vec3 \\
  /max: vec3 \\
  velocity: vec3 \\
  coords: int[2][4][2]
}{
  getBlocks(world: World) \\
  move(delta: vec3)
}
\umlsimpleclass[x=6,y=-4,alias=UMLClass4]{ChunkBlock}
\umlinherit[name=Relation0,geometry=--]{UMLClass0}{UMLClass1}
\umlcompo[name=Relation1,geometry=--,mult1=1,mult2=1,arg2={aabb}]{UMLClass1}{UMLClass2}
\umlimport[name=Relation2,geometry=--,mult1=1,mult2=1]{UMLClass0}{UMLClass3}
\node[above] at (2.4,0){$\ll$uses$\gg$};
\umluniassoc[name=Relation3,geometry=--,mult1=1,mult2=0..16,arg2={blocks}]{UMLClass3}{UMLClass4}
\end{gfx}


\FloatBarrier

\subsubsection{GUI und Inventar}

usecase hinzufügen: f3 menü, inventar toggle

Dadurch, dass die grafische Benutzeroberfläche mithilfe einer Bibliothek und \texttt{OpenGL} realisiert wurde, lässt sich im folgenden nur eklären, wie das Inventar implementiert wurde.

\begin{gfx}{Verändertes Designmodell der Playerklasse und ihrer Beziehungen}{ui}{ht}
    \umlsimpleclass[x=14.50,y=-7.50,alias=UMLClass0]{Player}
    \umlsimpleclass[x=14.60,y=-5.50,alias=UMLClass1]{Entity}
    \umlsimpleclass[x=19.40,y=-5.50,alias=UMLClass2]{AABB}
    \umlsimpleclass[x=14.50,y=-12.30,alias=UMLClass3]{ItemStack}
    \umlsimpleclass[x=14.50,y=-14.70,alias=UMLClass4]{Material}
    \umlsimpleclass[x=11.00,y=-5.50,alias=UMLClass5]{PlayState}
    \umlsimpleclass[x=14.50,y=-9.90,alias=UMLClass6]{Inventory}
    \umlinherit[name=Relation0,geometry=--,anchor1=71.6,anchor2=-90.0]{UMLClass0}{UMLClass1}
    \umlcompo[name=Relation1,geometry=--,anchor1=-4.1,anchor2=-175.9]{UMLClass1}{UMLClass2}
    \umlcompo[name=Relation2,geometry=--,anchor1=-71.6,anchor2=71.6,mult1={1},pos1=0.2,mult2={*},arg2={slots},pos2=0.8]{UMLClass6}{UMLClass3}
    \umlcompo[name=Relation3,geometry=--,anchor1=-71.6,anchor2=71.6,mult1={*},pos1=0.2,mult2={1},arg2={material},pos2=0.8]{UMLClass3}{UMLClass4}
    \umlcompo[name=Relation4,geometry=|-,anchor1=-90.0,anchor2=-177.3,mult1={*},pos1=0.2,mult2={1},arg2={player},pos2=1.8]{UMLClass5}{UMLClass0}
    \umlcompo[name=Relation5,geometry=--,anchor1=-71.6,anchor2=71.6,mult1={1},pos1=0.2,mult2={1},arg2={inventory},pos2=0.8]{UMLClass0}{UMLClass6}
\end{gfx}

Wie bereits beschrieben, dient die Klasse \texttt{Inventory} dazu, das Inventar zentral zu verwalten. Der Spieler hat genau ein Inventar und das Inventar mehrere slots gemäß der definierten Konstante \texttt{MAX\_INV\_SLOTS}.

Durch die neue GUI stehen dem Spieler auch zwei neue Use-Cases zur verfügung. Der Spieler kann mit (I) seine "Hotbar" also sein Inventarleiste verstecken und wieder anzeigen und mit (F3) kann der Spieler eine Debug-Pbersicht über Standard-Daten erhalten, wie die Himmelsrichtuing und die Koordinaten des Spielers.

\subsubsection*{UC08 – Inventarleiste umschalten}

\textbf{Name:} Inventarleiste umschalten \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Verstecken oder Anzeigen der Hotbar \\
\textbf{Vorbedingungen:} Spielfigur ist aktiv \\
\textbf{Nachbedingungen:} Die Hotbar ist aktiv oder versteckt je nach vorherigem Zustand \\
\textbf{Beschreibung:} Spieler kann Items im Inventar anzeigen und verstecken

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spieler drückt (I)
  \item[2.] Spiel versteckt die Inventarleiste
  \item[2a.] Inventarleiste ist versteckt
  \item[2a.1.] Spiel zeigt die Inventarleiste
  \item[3.] Use-Case endet erfolgreich
\end{description}

\subsubsection*{UC09 – Debug-Menü umschalten}

\textbf{Name:} Debug-Menü umschalten \\
\textbf{Akteur:} Spieler \\
\textbf{Ziel:} Verstecken oder Anzeigen des Debug-Menüs \\
\textbf{Vorbedingungen:} Spielfigur ist aktiv \\
\textbf{Nachbedingungen:} Das Debug-Menü ist aktiv oder versteckt je nach vorherigem Zustand \\
\textbf{Beschreibung:} Spieler kann Daten im Debug-Menü anzeigen und verstecken

\textbf{Ablaufspezifikation:}
\begin{description}[style=nextline,leftmargin=1.9cm,labelwidth=1.6cm]
  \item[1.] Spieler drückt (F3)
  \item[2.] Spiel zeigt das Debug-Menü
  \item[2a.] Debug-Menü ist aktiv
  \item[2a.1.] Spiel versteckt das Debug-Menü
  \item[3.] Use-Case endet erfolgreich
\end{description}

\FloatBarrier

\subsection{Fazit}

Nach dem Umsetzen des Projektes, mit den uns selber gestellten Veränderungen, fallen mehrere Punkte auf, die ihre Aufmerksamkeit verdienen. Dabei geht es um positive, als auch negative Aspekte, die aber allesamt zur Lektion beitragen.
\newline
\begin{description}
  \item[Codebase] Zunächst einmal sollte man sich vor beginnen des Projektes, und überlegen der Veränderungen, die Codebase anschauen. In unserem Fall kam der Aspekt zu kurz. Dies wurde uns dadurch zum Verhängnis, dass einiges an Zeit allein zum Verständnis des Codes aufgewandt werden musste. Die Schwierigkeit daran lag zum Teil auch im Umfang des Codes. Für ein Projekt im Kontext des Studiums lässt sich zusammenfassend sagen, dass es schlichtweg zu viel ist. Dadurch mangelte es stetig an Überblick.
  \item[Pflege der Codebase] Erschwerend zu der umfangreichen Codebase kam die fehlende Pflege des Codes hinzu. Das ursprüngliche Projekt wurde innerhalb einer Woche geschrieben mit einem tatsächlichen Zeitaufwand von 17 stunden. Das spiegelt sich leider in auskommentierten, nicht erklärten Codeblöcken oder auch in dem äu\ss{}erst unmodularen Design wieder. Eine sorgfältige Analyse des Projekts hätte dem entgegen wirken und uns dabei helfen können, ein geeigneteres zu finden.
  \item[OpenGL] Sobald der Code einigermaßen nachvollzogen wurde, kommt OpenGL ins Spiel. Die Schwierigkeit bestand darin, herauszufinden, wie man mit SFML und OpenGL eine 2D-Grafik über eine 3D-Grafik zeichnet. Dies war leider nicht sehr intuitiv und wurde weiter durch den umfangreichen Code erschwert. Erwähnenswert ist jedoch, dass nach dem Verstehen des Ablaufs von OpenGL-3D-Rendering und OpenGL-2D-Rendering die Nutzung deutlich einfacher war. So lässt sich feststellen, dass immer dazu gelernt wird, und einige Prozesse nicht so funktionieren, wie man sich diese vorstellt.
  \item[Buildprozess] Ein kleineres Problem hingegen war der Buildprozess. Dadurch, dass das Projekt ursprünglich auf Windows entwickelt wurde war der Buildprozess für Linux-Distributionen nicht ausreichend beschrieben. Es war einiges an Recherche nötig, um zu verstehen, welche schritte zusätzlich nötig waren um das Projekt zu bauen. Letztlich war das auch wieder ein Punkt, an dem nützliche Prozesse gelernt wurden. So wie zum Beispiel die Verwendung von CMake, welches noch nicht allen von uns geläufig war. Für die Zukunft sollte man sich des Buildprozesses mit CMake bewusst sein, weil es sehr nützlich ist. 
  \item[Versionsverwaltung mit Git] Besonders positiv jedoch ist die Versionsverwaltung mit Git. Git ist eine mächtige Software und dadurch auch sehr populär. Vor allem das Arbeiten in Branches hat die Arbeit mit mehreren Personen stark vereinfacht. Dadurch war der Entwicklungsprozess war  übersichtlich, da sich jeder auf seinen Teil konzentrieren konnte. Damit wurde während dieses Projekts auch die Arbeit.
  \item[Diagramme] Die Diagramme haben nicht nur dabei geholfen, anderen Personen zu erklären, wie das Projekt aufgebaut ist, sondern dienten auch dazu sich mit dem Code auseinanderzusetzen und selber zu verstehen, wie die einzelnen Komponenten interagieren. Schließlich kann kein Diagramm ohne Verständnis des jeweiligen Codes erzeugt werden.
\end{description}

Zusammfassend war das Projekt sehr lehrreich. Wir erarbeiteten uns Wissen mit CMake und OpenGL. Zusätzlich haben wir unser Wissen in der Programmiersprache C++, und somit auch in objektorientierter Programmierung, noch weiter vertieft. Zukünftig sollte man jedoch immer erst den Code sichten und ihn verstehen. Es ist wichtig eine Idee zu haben, warum Code so geschrieben wurde, um eigene Änderungen besser integrieren zu können. Mit diesem Fazit endet ein sehr spannendes, umfangreiches und lehrreiches Projekt.

%\begin{tikzpicture}
%  \node at (0,0) [name=start]{start};
%  \node at (3,3) [name=end]{end};
%  \umlaggreg[name=sartend]{start}{end};
%\end{tikzpicture}

\newpage

%%% Verzeichnisse %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Anhang}

In diesem Abschnitt finden sich verschiedene Verzeichnisse der genutzten 
Ressourcen, sowie zusätzliche Anhänge von Ressourcen, die nicht direkt im 
Hauptteil des Dokuments enthalten sind.

\listoffigures
%\listoftables
%\listofcode

\iffalse
\section*{Arbeitsverteilung}

\subsection*{Benjamin Brohs}
\begin{mylist}
  \mylistentry{sec:intro}
\end{mylist}
\fi

\newpage
%%% Anhänge %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure} [ht]
  \centering
  \includegraphics[angle=90,width=.65\linewidth]{design_full.png}
  \caption{Designmodell}
  \label{pic:design}
\end{figure}

\iffalse
\begin{figure}[ht]
  \hspace{-4.5cm}
  \includegraphics[width=0.95\paperwidth]{config_class.png}
  \caption{Domänenmodell}
  \label{fig:domain}
\end{figure}
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}